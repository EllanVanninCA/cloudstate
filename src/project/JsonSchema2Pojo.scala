import java.security.MessageDigest
import java.util.{Base64, Collections}

import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import com.sun.codemodel.JCodeModel
import org.jsonschema2pojo.rules.RuleFactory
import org.jsonschema2pojo._
import sbt._
import sbt.plugins.JvmPlugin
import sbt.Keys.{sourceGenerators, _}

import scala.collection.JavaConverters._
import scala.beans.{BeanProperty, BooleanBeanProperty}

object JsonSchema2Pojo extends AutoPlugin {

  object autoImport {
    val jsonSchema2Pojo = taskKey[JsonSchema2PojoResult]("Generate pojos from JSON schema")
    val jsonSchema2PojoSources = taskKey[Seq[File]]("The sources generated by jsonschema2proto")
    val jsonSchema2PojoResources = taskKey[Seq[File]]("The resources generated by jsonschema2proto")
    val jsonSchema2PojoConfig = settingKey[JsonSchema2PojoConfig]("Generation config object for jsonschema2pojo")
    val jsonSchema2PojoMappings = taskKey[Seq[JsonSchema2PojoMapping]]("The mappings of source files to class names and configurations")

    private val defaultConfig = new DefaultGenerationConfig

    case class JsonSchema2PojoResult(sources: Seq[File], resources: Seq[File])
    case class JsonSchema2PojoMapping(source: URL, className: String, config: JsonSchema2PojoConfig)

    case class JsonSchema2PojoConfig(
      @BooleanBeanProperty generateBuilders: Boolean = defaultConfig.isGenerateBuilders,
      @BooleanBeanProperty usePrimitives: Boolean = defaultConfig.isUsePrimitives,
      @BeanProperty targetPackage: String = defaultConfig.getTargetPackage,
      propertyWordDelimiters: List[Char] = defaultConfig.getPropertyWordDelimiters.toList,
      @BooleanBeanProperty useLongIntegers: Boolean = defaultConfig.isUseLongIntegers,
      @BooleanBeanProperty useBigIntegers: Boolean = defaultConfig.isUseBigIntegers,
      @BooleanBeanProperty useDoubleNumbers: Boolean = defaultConfig.isUseDoubleNumbers,
      @BooleanBeanProperty useBigDecimals: Boolean = defaultConfig.isUseBigDecimals,
      @BooleanBeanProperty includeHashcodeAndEquals: Boolean = defaultConfig.isIncludeHashcodeAndEquals,
      @BooleanBeanProperty includeToString: Boolean = defaultConfig.isIncludeToString,
      toStringExcludes: List[String] = defaultConfig.getToStringExcludes.toList,
      @BeanProperty annotationStyle: AnnotationStyle = defaultConfig.getAnnotationStyle,
      @BooleanBeanProperty useTitleAsClassname: Boolean = defaultConfig.isUseTitleAsClassname,
      @BeanProperty inclusionLevel: InclusionLevel = defaultConfig.getInclusionLevel,
      @BeanProperty customAnnotator: Class[_ <: Annotator] = defaultConfig.getCustomAnnotator,
      @BeanProperty customRuleFactory: Class[_ <: RuleFactory] = defaultConfig.getCustomRuleFactory,
      @BooleanBeanProperty includeJsr303Annotations: Boolean = defaultConfig.isIncludeJsr303Annotations,
      @BooleanBeanProperty includeJsr305Annotations: Boolean = defaultConfig.isIncludeJsr305Annotations,
      @BooleanBeanProperty useOptionalForGetters: Boolean = defaultConfig.isUseOptionalForGetters,
      @BeanProperty sourceType: SourceType = defaultConfig.getSourceType,
      @BooleanBeanProperty removeOldOutput: Boolean = defaultConfig.isRemoveOldOutput,
      @BeanProperty outputEncoding: String = defaultConfig.getOutputEncoding,
      @BooleanBeanProperty useJodaDates: Boolean = defaultConfig.isUseJodaDates,
      @BooleanBeanProperty useJodaLocalDates: Boolean = defaultConfig.isUseJodaLocalDates,
      @BooleanBeanProperty useJodaLocalTimes: Boolean = defaultConfig.isUseJodaLocalTimes,
      @BooleanBeanProperty parcelable: Boolean = defaultConfig.isParcelable,
      @BooleanBeanProperty serializable: Boolean = defaultConfig.isSerializable,
      @BooleanBeanProperty initializeCollections: Boolean = defaultConfig.isInitializeCollections,
      @BeanProperty classNamePrefix: String = defaultConfig.getClassNamePrefix,
      @BeanProperty classNameSuffix: String = defaultConfig.getClassNameSuffix,
      @BooleanBeanProperty includeConstructors: Boolean = defaultConfig.isIncludeConstructors,
      @BooleanBeanProperty constructorsRequiredPropertiesOnly: Boolean = defaultConfig.isConstructorsRequiredPropertiesOnly,
      @BooleanBeanProperty includeAdditionalProperties: Boolean = defaultConfig.isIncludeAdditionalProperties,
      @BooleanBeanProperty includeGetters: Boolean = defaultConfig.isIncludeGetters,
      @BooleanBeanProperty includeSetters: Boolean = defaultConfig.isIncludeSetters,
      @BeanProperty targetVersion: String = defaultConfig.getTargetVersion,
      @BooleanBeanProperty includeDynamicAccessors: Boolean = defaultConfig.isIncludeDynamicAccessors,
      @BooleanBeanProperty includeDynamicGetters: Boolean = defaultConfig.isIncludeDynamicGetters,
      @BooleanBeanProperty includeDynamicSetters: Boolean = defaultConfig.isIncludeDynamicSetters,
      @BooleanBeanProperty includeDynamicBuilders: Boolean = defaultConfig.isIncludeDynamicBuilders,
      @BeanProperty dateTimeType: String = defaultConfig.getDateTimeType,
      @BeanProperty dateType: String = defaultConfig.getDateType,
      @BeanProperty timeType: String = defaultConfig.getTimeType,
      @BooleanBeanProperty formatDates: Boolean = defaultConfig.isFormatDates,
      @BooleanBeanProperty formatTimes: Boolean = defaultConfig.isFormatTimes,
      @BooleanBeanProperty formatDateTimes: Boolean = defaultConfig.isFormatDateTimes,
      @BeanProperty customDatePattern: String = defaultConfig.getCustomDatePattern,
      @BeanProperty customTimePattern: String = defaultConfig.getCustomTimePattern,
      @BeanProperty customDateTimePattern: String = defaultConfig.getCustomDateTimePattern,
      @BeanProperty refFragmentPathDelimiters: String = defaultConfig.getRefFragmentPathDelimiters,
      @BeanProperty sourceSortOrder: SourceSortOrder = defaultConfig.getSourceSortOrder,
      @BeanProperty targetLanguage: Language = defaultConfig.getTargetLanguage,
      formatTypeMapping: Map[String, String] = defaultConfig.getFormatTypeMapping.asScala.toMap
    ) extends GenerationConfig {
      override def getSource: java.util.Iterator[URL] = Collections.emptyIterator()

      override def getTargetDirectory: File = new File(".")

      override def getPropertyWordDelimiters: Array[Char] = propertyWordDelimiters.toArray

      override def getToStringExcludes: Array[String] = toStringExcludes.toArray

      override def getFileFilter: java.io.FileFilter = defaultConfig.getFileFilter

      override def getFileExtensions: Array[String] = Array()

      override def getFormatTypeMapping: java.util.Map[String, String] = mapAsJavaMap(formatTypeMapping)
    }

  }

  import autoImport._

  override def trigger = noTrigger

  override def requires = JvmPlugin

  override def projectSettings: Seq[Def.Setting[_]] =
    inConfig(Compile)(scopedSettings) ++
      inConfig(Test)(scopedSettings) ++
      unscopedSettings

  private def unscopedSettings: Seq[Def.Setting[_]] = Seq(
    jsonSchema2PojoConfig := JsonSchema2PojoConfig()
  )

  private def scopedSettings: Seq[Def.Setting[_]] = Seq(
    jsonSchema2Pojo / includeFilter := "*.json" | "*.yaml",
    jsonSchema2Pojo / excludeFilter := HiddenFileFilter,
    jsonSchema2Pojo / sourceDirectory := sourceDirectory.value / "schemas",

    jsonSchema2Pojo / sourceDirectories := Seq((jsonSchema2Pojo / sourceDirectory).value),
    jsonSchema2Pojo / sources := Defaults.collectFiles(
      jsonSchema2Pojo / sourceDirectories,
      jsonSchema2Pojo / includeFilter,
      jsonSchema2Pojo / excludeFilter
    ).value,

    target in jsonSchema2PojoSources := crossTarget.value / "jsonschema2pojo" / Defaults.nameForSrc(configuration.value.name) / "sources",
    target in jsonSchema2PojoResources := crossTarget.value / "jsonschema2pojo" / Defaults.nameForSrc(configuration.value.name) / "resources",

    jsonSchema2PojoMappings := {
      val srcs = (jsonSchema2Pojo / sources).value
      val srcDirs = (jsonSchema2Pojo / sourceDirectories).value
      val config = jsonSchema2PojoConfig.value

      (srcs pair Path.relativeTo(srcDirs)).map {
        case (source, path) =>
          val fileName :: packageComponents = path.split("/").toList.reverse
          val pkg = packageComponents.reverse.mkString(".")
          val (className, ext) = fileName.span(_ != '.')

          // Heuristic to json/yaml based on file extension and whether we're using schemas or prototypes
          val sourceType = (ext, config.sourceType) match {
            case (".json", SourceType.YAML) => SourceType.JSON
            case (".json", SourceType.YAMLSCHEMA) => SourceType.JSONSCHEMA
            case (".yaml", SourceType.JSON) => SourceType.YAML
            case (".yaml", SourceType.JSONSCHEMA) => SourceType.YAMLSCHEMA
            case _ => config.sourceType
          }

          JsonSchema2PojoMapping(source.toURI.toURL, className, config.copy(targetPackage = pkg, sourceType = sourceType))
      }
    },


    jsonSchema2Pojo := jsonSchema2PojoTask.value,
    jsonSchema2PojoSources := jsonSchema2Pojo.value.sources,
    jsonSchema2PojoResources := jsonSchema2Pojo.value.resources,

    sourceGenerators += jsonSchema2PojoSources.taskValue,
    managedSourceDirectories += (jsonSchema2PojoSources / target).value,
    resourceGenerators += jsonSchema2PojoResources.taskValue,
    managedResourceDirectories += (jsonSchema2PojoResources / target).value
  )

  private def jsonSchema2PojoTask = Def.task {
    compile(
      jsonSchema2PojoMappings.value,
      (jsonSchema2PojoSources / target).value,
      (jsonSchema2PojoResources / target).value,
      streams.value.log,
      streams.value.cacheDirectory / "jsonschema2pojo.md5"
    )
  }

  private def compile(mappings: Seq[JsonSchema2PojoMapping], sourcesTarget: File, resourcesTarget: File,
    log: Logger, cacheFile: File): JsonSchema2PojoResult = {

    sourcesTarget.mkdirs()
    resourcesTarget.mkdirs()

    if (!cacheFile.exists() || computeHash(mappings, sourcesTarget, resourcesTarget) != IO.read(cacheFile).trim) {
      // First clear the target directory
      IO.delete(sourcesTarget.listFiles())
      IO.delete(resourcesTarget.listFiles())

      mappings.foreach { mapping =>
        log.info("Converting schema for " + mapping.source)

        val codeModel = new JCodeModel()
        val contentResolver = mapping.config.sourceType match {
          case SourceType.YAML | SourceType.YAMLSCHEMA => new ContentResolver(new YAMLFactory)
          case _ => new ContentResolver
        }

        val mapper = new SchemaMapper(new RuleFactory(mapping.config, new Jackson2Annotator(mapping.config),
          new SchemaStore(contentResolver)), new SchemaGenerator())

        mapper.generate(codeModel, mapping.className, mapping.config.targetPackage, mapping.source)

        val resourcesWriter = new FileCodeWriterWithEncoding(resourcesTarget, "utf-8")
        val sourcesWriter = mapping.config.targetLanguage match {
          case Language.SCALA =>
            log.warn("Scala target language generation does not work on Scala 2.12 (which sbt 1.x uses). You will get a NoClassDefFoundError.")
            new ScalaFileCodeWriter(sourcesTarget, "utf-8")
          case Language.JAVA => new FileCodeWriterWithEncoding(sourcesTarget, "utf-8")
        }

        codeModel.build(sourcesWriter, resourcesWriter)
      }

      // Store cache
      IO.write(cacheFile, computeHash(mappings, sourcesTarget, resourcesTarget))
    }

    def listOutputFiles(f: File): List[File] = {
      if (f.isDirectory) {
        f.listFiles.toList.flatMap(listOutputFiles)
      } else {
        List(f)
      }
    }

    JsonSchema2PojoResult(listOutputFiles(sourcesTarget), listOutputFiles(resourcesTarget))
  }

  private def computeHash(mappings: Seq[JsonSchema2PojoMapping], sourcesTarget: File, resourcesTarget: File): String = {
    // Crude check to see if we need to recompile
    val md = MessageDigest.getInstance("md5")

    def update(value: Any) = md.update(value.toString.getBytes("utf-8"))

    update("sources")
    mappings.sortBy(_.source.toString).foreach { mapping =>
      update(mapping)
      if (mapping.source.getProtocol == "file") {
        update(new File(mapping.source.toURI).lastModified())
      }
    }

    def addTarget(f: File): Unit = {
      if (f.isDirectory) {
        f.listFiles().sortBy(_.getName).foreach(addTarget)
      } else {
        update(f.getAbsolutePath)
        update(f.lastModified)
      }
    }
    update("sourcesTarget")
    addTarget(sourcesTarget)
    update("resourcesTarget ")
    addTarget(resourcesTarget)

    Base64.getEncoder.encodeToString(md.digest())
  }
}
